# Лабораторная работа №1 

Задача - выделить последовательность RR-интервалов из сигнала ЭКГ.

## Дано:

1. 20 файлов в формате `.txt`, содержащие амплитуду сигнала кардиограммы
2. Из каждого файла с кардиограммой необходимо выделить последовательности RR-интервалов и 
   сохранить их в файл

## Что надо сделать

### Шаг 0.1. Подготовка. Окружение и Pull Request

1. Создать форк репозитория
1. Установить необходимые инструменты для работы
1. Изменить файл `main.py`
1. Закоммитить изменения и создать pull request

**Важно:** в файле `main.py` вы должны написать код, рассчитывающий последовательность RR-интервалов (мс) из ЭКГ.
Для этого реализуйте функции в модуле `main.py` и весь код, 
выполняющий расчет RR-интервалов, должен быть выполнен в блоке `__main__`:

```py
if __name__ == '__main__':
  # your code goes here
  pass
 ```

> В рамках данной лабораторной работы **НЕЛЬЗЯ использовать сторонние модули и модули
> collections, pyhrv.**

## Шаг 0.2. Подготовка. Скачать файл с сырым сигналом ECG и положить в каталог

В рамках данного курса вы работаете с данными, собранными
в результате психофизиологического эксперимента, в рамках исследования механизмов эмоций. Они доступны
онлайн и составляют часть публичного набора данных (датасета): 
[POPANE DATASET - Psychophysiology Of Positive And Negative Emotions](https://osf.io/94bpx/).
Подробнее о деталях этого эксперимента и об актуальности данного
исследования можно узнать у консультанта курса. Структура датасета описана в 
[отдельном документе](../docs/data.md).

В Лабораторной работе №1 требуется извлечь RR интервалы из ECG сигнала. ECG сигнал
представлен в виде текстового файла. Вам необходимо скачать пример такого файла
из папки на GDrive: [ссылка](https://drive.google.com/drive/folders/1RkT5XnM7kEpnzYP8gPuPStZRIuONQIzv?usp=sharing). 

> Внимание: скачать нужно только файл `participant_28_baseline_raw.txt`
Нужно создать каталог `lab_1/data` и поместить туда скачанный файл. В итоге у вас 
должна получиться следующая структура каталогов:

```
|-- lab_1
    |-- data
        |-- participant_28_baseline_raw.txt
    |-- __init__.py
    |-- main.py
|-- lab_2
|-- lab 3
```


## Шаг 1. Определить порог для детектирования максимумов

При работе с кардиограммой и поставленной задаче извлечения RR интервалов, необходимо уметь
на аналитическом уровне определять пороговое значение, которое будет использоваться в правиле для
извлечения R-пиков.

Формула расчета следующая: `0.8 * max`

Необходимо реализовать функцию, которая соответствует интерфейсу:

**Входы (аргументы функции)**: сигнал в виде списка чисел типа `float`
**Выходы (возвращаемое значение функции)**: число типа `float`, то есть искомое пороговое значение

Если на вход подаются некорректные значения, возвращается `None`.


**Объявление функции:** 

```py
def calculate_threshold(signal: list) -> float:
    pass
```


## Шаг 2. Определить моменты максимумов в сигнале ЭКГ

Теперь, зная пороговое значение, построим правило для извлечения R пиков: все значения, большие либо равные
пороговому значению и удовлетворяющие условию, что предыдущее и последующее значения в последовательности меньше 
текущего помечаются как `1`, а все остальные значения: меньше порога, или не удовлетворяющие условию помечаются как `0`.

Необходимо реализовать функцию, которая соответствует интерфейсу:

**Входы (аргументы функции)**: 

1. сигнал в виде списка чисел
1. пороговое значение (типа float)

**Выходы (возвращаемое значение функции)**: список с метками типа bool

Если на вход подаются некорректные значения, возвращается `None`.

> Вопрос для самопроверки: какого размера будет список меток относительно списка с сырым сигналом?


**Объявление функции:** 

```py
def detect_maximums(signal: list, threshold: int) -> list:
    pass
```

## Шаг 3. Определить временные метки для каждого момента сигнала ЭКГ

Напомним, что исходная задача состоит в извлечении RR интервалов - промежутков времени между 
соседними R-пиками, измеряемых в мс. Мы уже умеем детектировать R-пики в сигнале, теперь нужно узнать в какой
момент времени каждый из R-пиков произошел. Для этого нам нужно знать частоту дискретизации сигнала,
то есть количество раз в секунду, когда датчик электрокардиографии производил опрос данных с человека.

Наши тестовые данные имеют частоту дискретизации 1000 Гц. 1 Гц означает получение 1 точки данных 
(в данном случае амплитуды ЭКГ сигнала) в секунду. Первое значение в заданном сигнале считаем 
произошедшим в момент времени `0`.

Необходимо реализовать функцию, которая соответствует интерфейсу:

**Входы (аргументы функции)**: 

1. сигнал в виде списка чисел
1. частота дискретизации, Гц

**Выходы (возвращаемое значение функции)**: список с временными метками, мс

Если на вход подаются некорректные значения, возвращается `None`.

> Вопрос для самопроверки: какого размера будет список меток относительно списка с сырым сигналом?


**Объявление функции:** 

```py
def calculate_times(signal: list, sample_rate: int) -> list:
    pass
```

## Шаг 4. Рассчитать RR-интервалы

Итак, у нас есть три списка: временные метки, метки максимумов и сырой сигнал - всё 
необходимое для извлечения RR интервалов. Вспомним еще раз, что RR интервалы - это
длительности промежутков времени между соседними максимумами, представленные в мс.

**Длина RR-интервалов человека не может быть меньше 400 мс.**

> **ПОДСКАЗКА** В итоговом списке RR интервалов не должно оказаться значений, меньших чем 400.
> Для этого рекомендуется сначала рассчитать все RR интервалы, а затем оставить только
> удовлетворяющие заявленному условию.

Необходимо реализовать функцию, которая соответствует интерфейсу:

**Входы (аргументы функции)**: 

1. список меток времени
1. список меток максимумов

**Выходы (возвращаемое значение функции)**: список с RR интервалами, мс

Если на вход подаются некорректные значения, возвращается `None`.


**Объявление функции:** 

```py
def calculate_rr(maximums: list, times: list) -> list:
    pass
```
